"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const oc_vite_1 = __importDefault(require("oc-vite"));
const vite_plugin_environment_1 = __importDefault(require("vite-plugin-environment"));
const oc_hash_builder_1 = __importDefault(require("oc-hash-builder"));
const oc_view_wrapper_1 = __importDefault(require("oc-view-wrapper"));
const cssModulesPlugin_1 = __importDefault(require("./cssModulesPlugin"));
const providerFunctions_1 = require("./providerFunctions");
const htmlTemplate_1 = __importDefault(require("./htmlTemplate"));
const clientName = 'clientBundle';
const removeExtension = (path) => path.replace(/\.(t|j)sx?$/, '');
const partition = (array, predicate) => {
    const matches = [];
    const rest = [];
    for (const element of array) {
        if (predicate(element)) {
            matches.push(element);
        }
        else {
            rest.push(element);
        }
    }
    return [matches, rest];
};
const defaultViewWrapper = ({ viewPath }) => `import View from "${removeExtension(viewPath)}";

  export default function renderer(props, element) {
    const { _staticPath, _baseUrl, _componentName, _componentVersion, ...rest } = props;

    element.innerHTML = View(props);
  }
  `;
async function compileView(options) {
    function processRelativePath(relativePath) {
        let pathStr = path_1.default.join(options.componentPath, relativePath);
        if (process.platform === 'win32') {
            return pathStr.split('\\').join('\\\\');
        }
        return pathStr;
    }
    const staticFiles = options.componentPackage.oc.files.static;
    let staticFolder = Array.isArray(staticFiles) ? staticFiles[0] : staticFiles;
    staticFolder = staticFolder?.replace(/^\//, '').replace(/\/$/, '');
    const viewFileName = options.componentPackage.oc.files.template.src;
    const componentPath = options.componentPath;
    const viewPath = processRelativePath(viewFileName);
    const publishPath = options.publishPath;
    const tempPath = path_1.default.join(publishPath, 'temp');
    const publishFileName = options.publishFileName || 'template.js';
    const componentPackage = options.componentPackage;
    const externals = options.externals || [];
    const production = !!options.production;
    const viewExtension = viewFileName.match(/\.(jsx?|tsx?)$/)?.[0] ?? '.js';
    const viewWrapperFn = options.viewWrapper || defaultViewWrapper;
    const viewWrapperContent = viewWrapperFn({ viewPath, providerFunctions: providerFunctions_1.providerFunctions });
    const viewWrapperName = `_viewWrapperEntry${viewExtension}`;
    const viewWrapperPath = path_1.default.join(tempPath, viewWrapperName);
    await fs_extra_1.default.outputFile(viewWrapperPath, viewWrapperContent);
    const globals = externals.reduce((externals, dep) => {
        externals[dep.name] = dep.global;
        return externals;
    }, {});
    const plugins = options?.plugins ?? [];
    const pluginsNames = plugins.map((x) => x?.name).filter(Boolean);
    const baseConfig = await oc_vite_1.default
        // @ts-ignore
        .loadConfigFromFile(process.cwd())
        .catch(() => null);
    const basePlugins = baseConfig?.config?.plugins?.filter((p) => !pluginsNames.includes(p?.name)) ?? [];
    const result = await oc_vite_1.default.build({
        appType: 'custom',
        root: componentPath,
        mode: production ? 'production' : 'development',
        plugins: [
            {
                name: 'OcServerRuntime',
                enforce: 'pre',
                transform(code, id) {
                    if (id.includes('node_modules/oc-server/dist/serverClient.js')) {
                        code = code.replace(/("|')COMPONENT_NAME("|')/, `"${componentPackage.name}"`);
                        code = code.replace(/("|')COMPONENT_VERSION("|')/, `"${componentPackage.version}"`);
                        return {
                            code,
                            map: null,
                        };
                    }
                    if (id.includes('node_modules/oc-server/dist/Server.js')) {
                        code = code.replace(/("|')__INITIAL__DATA__("|')/, '{}');
                        return {
                            code,
                            map: null,
                        };
                    }
                },
            },
            ...plugins,
            (0, vite_plugin_environment_1.default)(['NODE_ENV']),
            (0, cssModulesPlugin_1.default)(),
            ...basePlugins,
        ],
        logLevel: 'silent',
        build: {
            // Source map doesn't work properly because the bundle gets wrapped into more code and the
            // lines don't match anymore (would be nice to fix this somehow)
            sourcemap: false,
            lib: { entry: viewWrapperPath, formats: ['iife'], name: clientName },
            write: false,
            minify: production,
            rollupOptions: {
                external: Object.keys(globals),
                output: {
                    globals,
                },
            },
        },
        experimental: {
            renderBuiltUrl(filename, { hostType }) {
                if (hostType === 'js') {
                    return {
                        runtime: `__toOcStaticPathUrl(${JSON.stringify(filename)})`,
                    };
                }
                else {
                    return { relative: true };
                }
            },
        },
    });
    const out = (Array.isArray(result) ? result[0] : result);
    const bundle = out.output.find((x) => x?.facadeModuleId?.endsWith(viewWrapperName)).code;
    const [cssAssets, otherAssets] = partition(out.output.filter((x) => x.type === 'asset'), (x) => x.fileName.endsWith('.css'));
    const cssStyles = cssAssets
        .map((x) => x.source.replace(/\r?\n|\t/g, '') ??
        '')
        .join(' ')
        .replace(/'/g, '"');
    const bundleHash = oc_hash_builder_1.default.fromString(bundle);
    const wrappedBundle = `(function() {
    ${bundle}
    return ${clientName};
  })()`;
    const shortTemplateType = options.componentPackage.oc.files.template.type
        .replace('oc-template-', '')
        .replace(/-/, '');
    const templateId = `oc-${shortTemplateType}Root-${componentPackage.name}`;
    const hash = oc_hash_builder_1.default.fromString(wrappedBundle);
    const htmlTemplateWrapper = options.htmlTemplate || htmlTemplate_1.default;
    const templateString = htmlTemplateWrapper({
        templateId,
        templateName: shortTemplateType,
        css: cssStyles,
        externals,
        bundle: wrappedBundle,
        componentHash: bundleHash,
        hash,
    });
    const wrappedTemplateString = `function(model) {
    var __toOcStaticPathUrl = function(args) {
      return model.component.props._staticPath + '${staticFolder}/' + args;
    } 
    const { _staticPath, _baseUrl, _componentName, _componentVersion, ...rest } = model.component.props;
    var __$$oc_initialData__ = rest;
    var __$$oc_Settings__ = {id: model.id, staticPath: _staticPath, baseUrl: _baseUrl, name: _componentName, version: _componentVersion};
    var innerFn = ${templateString};
    return innerFn(model);
  }
  `;
    const view = (0, oc_view_wrapper_1.default)(hash, wrappedTemplateString);
    await fs_extra_1.default.unlink(viewWrapperPath);
    await fs_extra_1.default.mkdir(publishPath, { recursive: true });
    await fs_extra_1.default.writeFile(path_1.default.join(publishPath, publishFileName), view);
    if (staticFolder) {
        for (const asset of otherAssets) {
            // asset.fileName could have paths like assets/file.js
            // so we need to create those extra directories
            await fs_extra_1.default.ensureFile(path_1.default.join(publishPath, staticFolder, asset.fileName));
            await fs_extra_1.default.writeFile(path_1.default.join(publishPath, staticFolder, asset.fileName), asset.source, 'utf-8');
        }
    }
    return {
        template: {
            type: options.componentPackage.oc.files.template.type,
            hashKey: hash,
            src: publishFileName,
        },
        bundle: { hashKey: bundleHash },
    };
}
exports.default = (0, util_1.callbackify)(compileView);
